Selection Sort – Algorithm Theory
Selection Sort is a simple comparison-based sorting technique.
It repeatedly selects the smallest element from the unsorted part of the array and places it at the beginning.
Idea
The array is divided into sorted and unsorted parts.
Initially, the sorted part is empty.
In each pass, the minimum element from the unsorted part is selected.
That element is swapped with the first element of the unsorted part.
The process continues until the array is fully sorted.
Algorithm (Step-by-Step)
Start from the first element of the array.
Assume the current element is the minimum.
Compare it with the remaining elements to find the smallest.
Swap the smallest element with the current position.
Move to the next position.
Repeat until the array is sorted.
Pseudocode
Copy code

SelectionSort(A, n)
for i = 0 to n-2
    min = i
    for j = i+1 to n-1
        if A[j] < A[min]
            min = j
    swap A[i] and A[min]
end
Program Code (C Language)
Copy code
C
#include <stdio.h>

int main() {
    int a[50], n, i, j, min, temp;

    printf("Enter number of elements: ");
    scanf("%d", &n);

    printf("Enter elements:\n");
    for(i = 0; i < n; i++)
        scanf("%d", &a[i]);

    for(i = 0; i < n - 1; i++) {
        min = i;
        for(j = i + 1; j < n; j++) {
            if(a[j] < a[min])
                min = j;
        }

        temp = a[i];
        a[i] = a[min];
        a[min] = temp;
    }

    printf("Sorted array:\n");
    for(i = 0; i < n; i++)
        printf("%d ", a[i]);

    return 0;
}
Time & Space Complexity
Best Case: O(n²)
Average Case: O(n²)
Worst Case: O(n²)
Space Complexity: O(1)
Advantages
Simple and easy to implement
Performs well on small lists
Requires minimal memory
Disadvantages
Inefficient for large datasets
Not a stable sorting algorithm
Always takes O(n²) time
